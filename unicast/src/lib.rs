#![cfg_attr(docsrs, feature(doc_cfg, doc_auto_cfg))]

mod handler;
mod protocol;

use handler::Handler;
use libp2p_core::{Endpoint, Multiaddr};
use libp2p_identity::PeerId;
use libp2p_swarm::{
	behaviour::FromSwarm, ConnectionDenied, ConnectionId, NetworkBehaviour, THandler,
	THandlerInEvent, THandlerOutEvent, ToSwarm,
};
use std::time::Duration;
use std::{
	collections::VecDeque,
	task::{Context, Poll},
};

pub use self::protocol::PROTOCOL_NAME;
pub use handler::{Config, Failure};

/// A [`NetworkBehaviour`] that responds to inbound pings and
/// periodically sends outbound pings on every established connection.
///
/// See the crate root documentation for more information.
pub struct Behaviour {
	/// Configuration for outbound pings.
	config: Config,
	/// Queue of events to yield to the swarm.
	events: VecDeque<Event>,
}

/// Event generated by the `Ping` network behaviour.
#[derive(Debug)]
pub struct Event {
	/// The peer ID of the remote.
	pub peer: PeerId,
	/// The connection the ping was executed on.
	pub connection: ConnectionId,
	/// The result of an inbound or outbound ping.
	pub result: Result<Duration, Failure>,
}

impl Behaviour {
	/// Creates a new `Ping` network behaviour with the given configuration.
	pub fn new(config: Config) -> Self {
		Self { config, events: VecDeque::new() }
	}
}

impl Default for Behaviour {
	fn default() -> Self {
		Self::new(Config::new())
	}
}

impl NetworkBehaviour for Behaviour {
	type ConnectionHandler = Handler;
	type ToSwarm = Event;

	fn handle_established_inbound_connection(
		&mut self, _: ConnectionId, _: PeerId, _: &Multiaddr, _: &Multiaddr,
	) -> Result<THandler<Self>, ConnectionDenied> {
		Ok(Handler::new(self.config.clone()))
	}

	fn handle_established_outbound_connection(
		&mut self, _: ConnectionId, _: PeerId, _: &Multiaddr, _: Endpoint,
	) -> Result<THandler<Self>, ConnectionDenied> {
		Ok(Handler::new(self.config.clone()))
	}

	fn on_connection_handler_event(
		&mut self, peer: PeerId, connection: ConnectionId, result: THandlerOutEvent<Self>,
	) {
		self.events.push_front(Event { peer, connection, result })
	}

	#[tracing::instrument(level = "trace", name = "NetworkBehaviour::poll", skip(self))]
	fn poll(&mut self, _: &mut Context<'_>) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
		if let Some(e) = self.events.pop_back() {
			Poll::Ready(ToSwarm::GenerateEvent(e))
		} else {
			Poll::Pending
		}
	}

	fn on_swarm_event(&mut self, _event: FromSwarm) {}
}
